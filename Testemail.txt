package com.scb.scroeconnect.solaceworker.config;

import com.scb.scroeconnect.solaceworker.entity.ConnectSolaceConfig;
import com.solacesystems.jcsmp.*;
import com.solacesystems.jms.SolConnectionFactory;
import com.solacesystems.jms.SolJmsUtility;
import com.solacesystems.jms.message.SolMessage;
import lombok.extern.log4j.Log4j2;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Qualifier;
import org.springframework.context.ApplicationListener;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Lazy;
import org.springframework.context.event.ContextClosedEvent;
import org.springframework.stereotype.Component;

import javax.jms.Connection;
import javax.jms.Destination;
import javax.jms.JMSException;
import javax.jms.MessageProducer;
import javax.jms.Session;
import java.util.Map;

@Log4j2
@Component
public class SolaceConnectionConfig implements ApplicationListener<ContextClosedEvent> {

    private final ConnectSolaceConfig connectSolaceConfig;

    private final SolacePropertiesConstant solacePropertiesConstant;

    @Lazy
    @Autowired
    @Qualifier("rcmsSession")
    private Session session;

    @Lazy
    @Autowired
    @Qualifier("rcmsConnection")
    private Connection connection;

    public SolaceConnectionConfig(ConnectSolaceConfig connectSolaceConfig, SolacePropertiesConstant solacePropertiesConstant) {
        this.connectSolaceConfig = connectSolaceConfig;
        this.solacePropertiesConstant = solacePropertiesConstant;
    }

    @Bean("rcmsSolConnectionFactory")
    public SolConnectionFactory createSolConnectionFactory() throws Exception {
        Map<String, String> queue = solacePropertiesConstant.getQueue();
        Map<String, String> ssl = solacePropertiesConstant.getSsl();

        SolConnectionFactory cf = SolJmsUtility.createConnectionFactory();
        cf.setVPN(connectSolaceConfig.getVpn());
        cf.setHost(connectSolaceConfig.getHostname());
        cf.setUsername(connectSolaceConfig.getUsername());
        cf.setPassword(connectSolaceConfig.getPassword());
        cf.setConnectRetries(solacePropertiesConstant.getConnectRetries());
        cf.setConnectRetriesPerHost(solacePropertiesConstant.getConnectRetriesPerHost());
        cf.setConnectTimeoutInMillis(solacePropertiesConstant.getConnectTimeoutInMillis());
        cf.setClientID(connectSolaceConfig.getClientId());

        cf.setSSLTrustStore(ssl.get("truststorePath"));
        cf.setSSLTrustStorePassword(ssl.get("truststorePassword"));
        cf.setSSLTrustStoreFormat(ssl.get("truststoreType"));
        cf.setSSLKeyStore(ssl.get("keystorePath"));
        cf.setSSLKeyStorePassword(ssl.get("keystorePassword"));
        cf.setSSLKeyStoreFormat(ssl.get("keystoreType"));
        cf.setAuthenticationScheme("AUTHENTICATION_SCHEME_CLIENT_CERTIFICATE");
        return cf;
    }

    @Bean("rcmsConnection")
    public Connection createConnection(@Qualifier("rcmsSolConnectionFactory") SolConnectionFactory cf) throws Exception {
        return cf.createConnection();
    }

    @Bean("rcmsSession")
    public javax.jms.Session createSession(@Qualifier("rcmsConnection") Connection connection) throws Exception {
        return connection.createSession(false, javax.jms.Session.CLIENT_ACKNOWLEDGE);
    }

    @Override
    public void onApplicationEvent(ContextClosedEvent event) {
        if (session != null)
            try {
                session.close();
            } catch (JMSException e) {
                log.error("Error while closing session", e);
            }
        if (connection != null)
            try {
                connection.close();
            } catch (JMSException e) {
                log.error("Error while closing connection", e);
            }
    }

    public void sendMessage(String topicName, String message, String caseRef) throws JMSException {
        Destination destination = session.createTopic(topicName);
        MessageProducer producer = session.createProducer(destination);
        SolMessage textMessage = (SolMessage) session.createTextMessage((String) message);
        textMessage.setJMSTimestamp(System.currentTimeMillis());
        textMessage.setJMSCorrelationID(caseRef);
        producer.send(textMessage);
        log.info(textMessage.getJMSMessageID());
        if (producer != null) producer.close();
    }
}

package com.scb.scroeconnect.solaceworker.entity;

import jakarta.persistence.*;
import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;

@Entity
@Table(name = "connect_solace_config")
@Getter
@Setter
@AllArgsConstructor
@NoArgsConstructor
public class ConnectSolaceConfig extends BaseEntity {
    @Id
    @Column(name = "solace_config_id", nullable = false)
    private Long solaceConfigId;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "recipient_id",referencedColumnName = "id", nullable = false)
    private Recipient recipient;

    @Column(name = "host", nullable = false)
    private String hostname;

    @Column(name = "topic", nullable = false)
    private String topic;

    @Column(name = "clientId", nullable = false)
    private String clientId;

    @Column(name = "vpn", nullable = false)
    private String vpn;

    @Column(name = "username", nullable = false)
    private String username;

    @Column(name = "password", nullable = false)
    private String password;

    @Column(name = "active", nullable = false)
    private String active;
}

Description:

Parameter 0 of constructor in com.scb.scroeconnect.solaceworker.config.SolaceConnectionConfig required a bean of type 'com.scb.scroeconnect.solaceworker.entity.ConnectSolaceConfig' that could not be found.


Action:

Consider defining a bean of type 'com.scb.scroeconnect.solaceworker.entity.ConnectSolaceConfig' in your configuration.


Process finished with exit code 1

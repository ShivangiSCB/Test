package com.scb.scroeconnect.emailworker.entity;

import com.scb.scroeconnect.emailworker.converter.StringListConverter;
import jakarta.persistence.*;

import java.util.List;

@Entity
@Table(name = "connect_event_email_config")
public class ConnectEventEmailConfig {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    @Column(name = "email_config_id")
    private int email_config_id;

    @Column(name = "recipients")
    @Convert(converter = StringListConverter.class)
    private List<String> recipients;

    @Column(name = "cc")
    @Convert(converter = StringListConverter.class)
    private List<String> cc;

    @Column(name = "bcc")
    @Convert(converter = StringListConverter.class)
    private List<String> bcc;

    @Column(name = "reply_to")
    private String replyTo;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "recipient_id", referencedColumnName = "id", nullable = false)
    private ConnectNotificationRecipient recipient;

    public ConnectEventEmailConfig(int email_config_id, List<String> recipients, List<String> cc, List<String> bcc, String replyTo) {
        this.email_config_id = email_config_id;
        this.recipients = recipients;
        this.cc = cc;
        this.bcc = bcc;
        this.replyTo = replyTo;
    }

    public int getEmail_config_id() {
        return email_config_id;
    }

    public void setEmail_config_id(int email_config_id) {
        this.email_config_id = email_config_id;
    }

    public List<String> getRecipients() {
        return recipients;
    }

    public void setRecipients(List<String> recipients) {
        this.recipients = recipients;
    }

    public List<String> getCc() {
        return cc;
    }

    public void setCc(List<String> cc) {
        this.cc = cc;
    }

    public List<String> getBcc() {
        return bcc;
    }

    public void setBcc(List<String> bcc) {
        this.bcc = bcc;
    }

    public String getReplyTo() {
        return replyTo;
    }

    public void setReplyTo(String replyTo) {
        this.replyTo = replyTo;
    }

    public ConnectNotificationRecipient getRecipient() {
        return recipient;
    }

    public void setRecipient(ConnectNotificationRecipient recipient) {
        this.recipient = recipient;
    }
}

package com.scb.scroeconnect.emailworker.entity;

import jakarta.persistence.*;

import java.math.BigInteger;
import java.sql.Timestamp;
import java.util.UUID;

@Entity
@Table(name = "connect_notification_event")
public class ConnectNotificationEvent {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(nullable = false, unique = true ,name = "event_id")
    private UUID eventId;

    @Column(nullable = false,name = "client_id")
    private String clientId;

    @Column(nullable = false,name = "event_type")
    private String eventType;

    @Column(columnDefinition = "TEXT")
    private String payload;

    @Column(nullable = false)
    private String status;

    @Column(nullable = false, name = "available_at")
    private Timestamp availableAt;

    @Column(nullable = false,name = "retry_count")
    private Integer retryCount;

    public ConnectNotificationEvent() {
    }

    public Long getId() {
        return id;
    }

    public void setId(Long id) {
        this.id = id;
    }

    public UUID getEventId() {
        return eventId;
    }

    public void setEventId(UUID eventId) {
        this.eventId = eventId;
    }

    public String getClientId() {
        return clientId;
    }

    public void setClientId(String clientId) {
        this.clientId = clientId;
    }

    public String getEventType() {
        return eventType;
    }

    public void setEventType(String eventType) {
        this.eventType = eventType;
    }

    public String getPayload() {
        return payload;
    }

    public void setPayload(String payload) {
        this.payload = payload;
    }

    public String getStatus() {
        return status;
    }

    public void setStatus(String status) {
        this.status = status;
    }

    public Timestamp getAvailableAt() {
        return availableAt;
    }

    public void setAvailableAt(Timestamp availableAt) {
        this.availableAt = availableAt;
    }

    public Integer getRetryCount() {
        return retryCount;
    }

    public void setRetryCount(Integer retryCount) {
        this.retryCount = retryCount;
    }
}


package com.scb.scroeconnect.emailworker.config;

import com.scb.liquidity.configuration.hashicorp.*;
import com.scb.liquidity.configuration.HibernateFactory;
import com.zaxxer.hikari.HikariConfig;
import com.zaxxer.hikari.HikariDataSource;
import jakarta.persistence.EntityManagerFactory;
import lombok.Getter;
import lombok.Setter;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.context.properties.ConfigurationProperties;
import org.springframework.context.ApplicationListener;
import org.springframework.context.annotation.*;
import org.springframework.context.event.ContextClosedEvent;
import org.springframework.orm.jpa.JpaTransactionManager;
import org.springframework.orm.jpa.LocalContainerEntityManagerFactoryBean;
import org.springframework.orm.jpa.vendor.HibernateJpaVendorAdapter;
import org.springframework.transaction.PlatformTransactionManager;
import org.springframework.transaction.annotation.EnableTransactionManagement;

import java.util.Map;
import java.util.Properties;

@Getter
@Setter
@Configuration
@EnableTransactionManagement
@ConfigurationProperties(prefix = "scroe.db")
@Import(HashiCorpAutoConfig.class)
public class DBConfig implements ApplicationListener<ContextClosedEvent> {

    private static final String ENTITY_PACKAGE =
            "com.scb.scroeconnect.emailworker"; // chnage according to service

    @Autowired(required = false)
    private VaultAuthenticator vaultAuthenticator;

    @Autowired(required = false)
    private VaultDBSecrets vaultDBSecrets;

    private Map<String, String> datasource;
    private Map<String, String> hibernate;

    private LocalContainerEntityManagerFactoryBean emf;

    @Bean
    public HikariDataSource hikariDataSource() {
        HikariConfig hikariConfig =
                HibernateFactory.createHikariConfig(datasource, hibernate);

        hikariConfig.setConnectionTimeout(
                Long.parseLong(hibernate.get("connection_timeout_ms"))
        );

        return DataSourceConfig.createInstance(
                hikariConfig,
                vaultDBSecrets,
                vaultAuthenticator
        );
    }

    @Bean
    public LocalContainerEntityManagerFactoryBean entityManagerFactory(
            HikariDataSource dataSource) {

        LocalContainerEntityManagerFactoryBean factory =
                new LocalContainerEntityManagerFactoryBean();

        factory.setDataSource(dataSource);
        factory.setPackagesToScan(ENTITY_PACKAGE);

        HibernateJpaVendorAdapter vendorAdapter =
                new HibernateJpaVendorAdapter();

        vendorAdapter.setShowSql(
                Boolean.parseBoolean(hibernate.get("show_sql"))
        );

        factory.setJpaVendorAdapter(vendorAdapter);
        factory.setJpaProperties(jpaProperties());

        this.emf = factory;
        return factory;
    }

    @Bean(name="transactionManager")
    public PlatformTransactionManager transactionManager(
            EntityManagerFactory emf) {
        return new JpaTransactionManager(emf);
    }

    private Properties jpaProperties() {
        Properties props = new Properties();
        props.put("hibernate.show_sql", hibernate.get("show_sql"));
        props.put("hibernate.dialect", hibernate.get("dialect"));
        props.put("hibernate.hbm2ddl.auto", hibernate.get("hbm2ddl"));

        return props;
    }

    @Override
    public void onApplicationEvent(ContextClosedEvent event) {
        if (emf != null) {
            emf.destroy();
        }
    }
}

package com.scb.scroeconnect.emailworker.dto;

import com.fasterxml.jackson.databind.JsonNode;

import java.util.List;

public class EmailRequestDTO {
    private String _id;
    private String country;
    private List<String> recipients;
    private List<String> cc;
    private List<String> bcc;
    private String replyTo;
    private String notificationType;
    private String subject;
    private String contentType;
    private String contentBody;
    private String encoding;
    private String priority;
    private List<Object> attachments;

    public EmailRequestDTO() {
    }

    public String get_id() {
        return _id;
    }

    public void set_id(String _id) {
        this._id = _id;
    }

    public String getCountry() {
        return country;
    }

    public void setCountry(String country) {
        this.country = country;
    }

    public List<String> getRecipients() {
        return recipients;
    }

    public void setRecipients(List<String> recipients) {
        this.recipients = recipients;
    }

    public List<String> getCc() {
        return cc;
    }

    public void setCc(List<String> cc) {
        this.cc = cc;
    }

    public List<String> getBcc() {
        return bcc;
    }

    public void setBcc(List<String> bcc) {
        this.bcc = bcc;
    }

    public String getReplyTo() {
        return replyTo;
    }

    public void setReplyTo(String replyTo) {
        this.replyTo = replyTo;
    }

    public String getNotificationType() {
        return notificationType;
    }

    public void setNotificationType(String notificationType) {
        this.notificationType = notificationType;
    }

    public String getSubject() {
        return subject;
    }

    public void setSubject(String subject) {
        this.subject = subject;
    }

    public String getContentType() {
        return contentType;
    }

    public void setContentType(String contentType) {
        this.contentType = contentType;
    }

    public String getContentBody() {
        return contentBody;
    }

    public void setContentBody(String contentBody) {
        this.contentBody = contentBody;
    }

    public String getEncoding() {
        return encoding;
    }

    public void setEncoding(String encoding) {
        this.encoding = encoding;
    }

    public String getPriority() {
        return priority;
    }

    public void setPriority(String priority) {
        this.priority = priority;
    }

    public List<Object> getAttachments() {
        return attachments;
    }

    public void setAttachments(List<Object> attachments) {
        this.attachments = attachments;
    }
}

package com.scb.scroeconnect.emailworker;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.EnableAutoConfiguration;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.boot.hibernate.autoconfigure.HibernateJpaAutoConfiguration;
import org.springframework.boot.persistence.autoconfigure.EntityScan;
import org.springframework.cache.annotation.EnableCaching;
import org.springframework.data.jpa.repository.config.EnableJpaRepositories;
import org.springframework.scheduling.annotation.EnableScheduling;
import org.springframework.transaction.annotation.EnableTransactionManagement;

@SpringBootApplication(exclude = HibernateJpaAutoConfiguration.class)
@EnableJpaRepositories(basePackages =
        "com.scb.scroeconnect.emailworker.repository")
@EntityScan("com.scb.scroeconnect.emailworker.entity")
@EnableScheduling
public class EmailWorkerApplication {
    public static void main(String[] args) {
        SpringApplication.run(EmailWorkerApplication.class, args);
    }

}

package com.scb.scroeconnect.emailworker.dto;

import com.fasterxml.jackson.databind.JsonNode;

import java.nio.charset.StandardCharsets;
import java.util.Base64;
import java.util.Date;

public class EmailPayloadDTO {
    private String messageId;
    private String subject;
    private JsonNode contentBody;
    private String attachment;
    private String country;
    private String notificationType;
    private String contentType;
    private String priority;
    private String refId;
    private Date initiatedTimestamp;

    public EmailPayloadDTO() {
    }

    public JsonNode getContentBody() {
        return contentBody;
    }

    public String getMessageId() {
        return messageId;
    }

    public void setMessageId(String messageId) {
        this.messageId = messageId;
    }

    public String getSubject() {
        return subject;
    }

    public void setSubject(String subject) {
        this.subject = subject;
    }

    public void setContentBody(JsonNode contentBody) {
        this.contentBody = contentBody;
    }

    public String getRefId() {
        return refId;
    }

    public void setRefId(String refId) {
        this.refId = refId;
    }

    public String getAttachment() {
        return attachment;
    }

    public void setAttachment(String attachment) {
        this.attachment = attachment;
    }

    public Date getInitiatedTimestamp() {
        return initiatedTimestamp;
    }

    public void setInitiatedTimestamp(Date initiatedTimestamp) {
        this.initiatedTimestamp = initiatedTimestamp;
    }

    public String getCountry() {
        return country;
    }

    public void setCountry(String country) {
        this.country = country;
    }

    public String getNotificationType() {
        return notificationType;
    }

    public void setNotificationType(String notificationType) {
        this.notificationType = notificationType;
    }

    public String getContentType() {
        return contentType;
    }

    public void setContentType(String contentType) {
        this.contentType = contentType;
    }

    public String getPriority() {
        return priority;
    }

    public void setPriority(String priority) {
        this.priority = priority;
    }
}

package com.scb.scroeconnect.emailworker.converter;

import com.fasterxml.jackson.databind.ObjectMapper;
import com.scb.scroeconnect.emailworker.dto.EmailPayloadDTO;
import jakarta.persistence.AttributeConverter;
import jakarta.persistence.Converter;

@Converter(autoApply = false)
public class EmailPayloadConverter implements AttributeConverter<EmailPayloadDTO, String> {

    private static final ObjectMapper OBJECT_MAPPER = new ObjectMapper();

    @Override
    public String convertToDatabaseColumn(EmailPayloadDTO emailPayloadDTO) {
        if (emailPayloadDTO == null) return null;
        try {
            return OBJECT_MAPPER.writeValueAsString(emailPayloadDTO);
        } catch (Exception e) {
            throw new IllegalArgumentException("Failed to serialize EmailPayloadDTO", e);
        }
    }

    @Override
    public EmailPayloadDTO convertToEntityAttribute(String emailData) {
        if (emailData == null) return null;
        try {
            return OBJECT_MAPPER.readValue(emailData, EmailPayloadDTO.class);
        } catch (Exception e) {
            throw new IllegalArgumentException("Failed to deserialize EmailPayloadDTO", e);
        }
    }
}

package com.scb.scroeconnect.emailworker.service;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.scb.scroeconnect.emailworker.config.EmailWorkerConfig;
import com.scb.scroeconnect.emailworker.config.RetryableRestTemplate;
import com.scb.scroeconnect.emailworker.dto.EmailPayloadDTO;
import com.scb.scroeconnect.emailworker.dto.EmailRequestDTO;
import com.scb.scroeconnect.emailworker.entity.ConnectEventEmailConfig;
import com.scb.scroeconnect.emailworker.entity.ConnectNotificationDelivery;
import com.scb.scroeconnect.emailworker.repository.ConnectEventEmailConfigRepository;
import com.scb.scroeconnect.emailworker.repository.ConnectNotificationDeliveryRepository;
import jakarta.transaction.Transactional;
import lombok.extern.log4j.Log4j2;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;
import org.springframework.http.*;
import org.springframework.stereotype.Service;

import java.nio.charset.StandardCharsets;
import java.util.*;

@Log4j2
@Service
public class EmailWorkerService {
    private static final ObjectMapper OBJECT_MAPPER = new ObjectMapper();

    private static final Logger logger = LogManager.getLogger(EmailWorkerService.class);

    private final ConnectNotificationDeliveryRepository connectNotificationDeliveryRepository;
    private final ConnectEventEmailConfigRepository connectEventEmailConfigRepository;
    private RetryableRestTemplate restTemplate;
    private final EmailWorkerConfig emailWorkerConfig;

    public EmailWorkerService(ConnectEventEmailConfigRepository connectEventEmailConfigRepository, RetryableRestTemplate restTemplate, EmailWorkerConfig emailWorkerConfig, ConnectNotificationDeliveryRepository connectNotificationDeliveryRepository) {
        this.connectEventEmailConfigRepository = connectEventEmailConfigRepository;
        this.restTemplate = restTemplate;
        this.emailWorkerConfig = emailWorkerConfig;
        this.connectNotificationDeliveryRepository = connectNotificationDeliveryRepository;
    }

    @Transactional
    public void sendEmailNotification(ConnectNotificationDelivery connectNotificationDelivery) {

        ConnectNotificationDelivery delivery = connectNotificationDeliveryRepository.findById(connectNotificationDelivery.getId()).orElseThrow(() -> new IllegalStateException("Delivery not found"));

        logger.info("Get Transformed payload {}", delivery.getTransformedPayload());
        // ðŸ”’ Idempotency / retry safety
        if (delivery.getTransformedPayload().getMessageId() == null) {

            String messageId = UUID.randomUUID().toString();
            EmailPayloadDTO payload = delivery.getTransformedPayload();
            if (payload == null) {
                payload = new EmailPayloadDTO();
            }

            payload.setMessageId(messageId);
            payload.setInitiatedTimestamp(new Date());

            delivery.setTransformedPayload(payload);
        }

        logger.info("Get Final payload {}", delivery.getTransformedPayload());

        try {
            logger.info("Sending Email");
            sendEmail(delivery);
        } catch (Exception ex) {
            logger.error("Error while sending email", ex);
            throw new RuntimeException("Error while fetching Pending Email Deliveries:", ex);
        }
    }

    public boolean sendEmail(ConnectNotificationDelivery notificationDelivery) throws JsonProcessingException {
        Optional<ConnectEventEmailConfig> connectEventEmailConfigOptional = connectEventEmailConfigRepository.findByRecipientId(notificationDelivery.getRecipientId());

        logger.info("Get Recipients Details {}", connectEventEmailConfigOptional.get());

        if (connectEventEmailConfigOptional.isEmpty()) {
            return false;
        }

        UUID uuid = UUID.randomUUID();
        String messageId = uuid.toString();
        notificationDelivery.getTransformedPayload().setMessageId(messageId);
        notificationDelivery.getTransformedPayload().setInitiatedTimestamp(new Date());

        ConnectEventEmailConfig connectEventEmailConfig = connectEventEmailConfigOptional.get();

        String json = OBJECT_MAPPER.writeValueAsString(notificationDelivery.getTransformedPayload().getContentBody());
        String contentBody = Base64.getEncoder().encodeToString(json.getBytes(StandardCharsets.UTF_8));
        EmailRequestDTO body = new EmailRequestDTO();

        body.set_id("1001");
        body.setCountry(notificationDelivery.getTransformedPayload().getCountry());
        body.setRecipients(connectEventEmailConfig.getRecipients());
        body.setCc(connectEventEmailConfig.getCc());
        body.setBcc(connectEventEmailConfig.getBcc());
        body.setReplyTo(connectEventEmailConfig.getReplyTo());
        body.setNotificationType(notificationDelivery.getTransformedPayload().getNotificationType());
        body.setSubject(notificationDelivery.getTransformedPayload().getSubject());
        body.setContentType(notificationDelivery.getTransformedPayload().getContentType());
        body.setContentBody(contentBody.toString());
        body.setEncoding("");
        body.setPriority("");
        body.setAttachments(Collections.singletonList(""));

        logger.info("Get Send Email DTO {}", body);

        HttpHeaders headers = new HttpHeaders();
        headers.setContentType(MediaType.APPLICATION_JSON);

        HttpEntity<EmailRequestDTO> requestEntity = new HttpEntity<>(body, headers);

        try {
            ResponseEntity<String> resp =
                    restTemplate.exchange(
                            emailWorkerConfig.getSendEmailApi(),
                            HttpMethod.POST,
                            requestEntity
                    );

            return resp.getStatusCode().is2xxSuccessful();
        } catch (Exception ex) {
            logger.error("Error while sending email", ex);
            throw new RuntimeException("Error while fetching Pending Email Deliveries:", ex);
        }
    }
}

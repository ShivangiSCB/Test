package com.scb.scroeconnect.emailworker.converter;

import com.fasterxml.jackson.databind.ObjectMapper;
import com.scb.scroeconnect.emailworker.dto.EmailRequestDTO;
import jakarta.persistence.AttributeConverter;
import jakarta.persistence.Converter;

@Converter(autoApply = false)
public class EmailRequestDTOConverter implements AttributeConverter<EmailRequestDTO, String> {

    private static final ObjectMapper OBJECT_MAPPER = new ObjectMapper();

    @Override
    public String convertToDatabaseColumn(EmailRequestDTO emailPayloadDTO) {
        if (emailPayloadDTO == null) return null;
        try {
            return OBJECT_MAPPER.writeValueAsString(emailPayloadDTO);
        } catch (Exception e) {
            throw new IllegalArgumentException("Failed to serialize EmailPayloadDTO", e);
        }
    }

    @Override
    public EmailRequestDTO convertToEntityAttribute(String emailData) {
        if (emailData == null) return null;
        try {
            return OBJECT_MAPPER.readValue(emailData, EmailRequestDTO.class);
        } catch (Exception e) {
            throw new IllegalArgumentException("Failed to deserialize EmailPayloadDTO", e);
        }
    }
}

package com.scb.scroeconnect.emailworker.repository;

import com.scb.scroeconnect.emailworker.entity.ConnectNotificationEmailInfo;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

@Repository
public interface ConnectEmailInfoRepository extends JpaRepository<ConnectNotificationEmailInfo,Long> {
}

package com.scb.scroeconnect.emailworker.repository;

import com.scb.scroeconnect.emailworker.entity.ConnectEventEmailConfig;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Query;
import org.springframework.data.repository.query.Param;
import org.springframework.stereotype.Repository;

import java.util.Optional;

@Repository
public interface ConnectEventEmailConfigRepository extends JpaRepository<ConnectEventEmailConfig, Integer> {

    @Query(value = "SELECT * " +
            "FROM connect_event_email_config WHERE recipient_id = :recipient_id", nativeQuery = true)
    Optional<ConnectEventEmailConfig> findByRecipientId(@Param("recipient_id") Long recipientId);

}

package com.scb.scroeconnect.emailworker.repository;

import com.scb.scroeconnect.emailworker.entity.ConnectNotificationDelivery;
import org.springframework.data.domain.Pageable;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Modifying;
import org.springframework.data.jpa.repository.Query;
import org.springframework.data.repository.query.Param;
import org.springframework.stereotype.Repository;
import org.springframework.transaction.annotation.Transactional;


import java.math.BigInteger;
import java.util.Date;
import java.util.List;

@Repository
public interface ConnectNotificationDeliveryRepository extends JpaRepository<ConnectNotificationDelivery, Long> {

    @Transactional
    @Query(value = """
            WITH claimed AS (
                        SELECT id
                        FROM connect_notification_delivery
                        WHERE(status = 'PENDING' OR status= 'RETRY')
                        AND delivery_mode = 'Email'
                        AND available_at <= NOW()
                        ORDER BY created_at
                        LIMIT :batchSize
                        FOR UPDATE SKIP LOCKED
                    )
                    UPDATE connect_notification_delivery
                    SET status = 'PROCESSING'
                    WHERE id IN (SELECT id FROM claimed)
                    RETURNING *
            """, nativeQuery = true)
    List<ConnectNotificationDelivery> findPendingEmailDeliveries(int batchSize);

    @Modifying
    @Transactional
    @Query(value = "UPDATE connect_notification_delivery SET status = :status, " +
            "retry_count = retry_count + 1, available_at = :availableAt, updated_at = NOW() WHERE id = :id", nativeQuery = true)
    void updateStatusAndRetryById(Long id, String status, Date availableAt);

    @Modifying
    @Transactional
    @Query(value = "UPDATE connect_notification_delivery SET status = :status, " +
            "updated_at = NOW() WHERE id = :id", nativeQuery = true)
    void updateStatusById(Long id, String status);

//    @Modifying
//    @Transactional
//    @Query(value = "UPDATE connect_notification_delivery SET status = 'FAILED', " +
//            "updated_at = NOW() WHERE id = :id", nativeQuery = true)
//    void updateStatusById(Long id, String status);
}

package com.scb.scroeconnect.emailworker.repository;

import com.scb.scroeconnect.emailworker.entity.ConnectNotificationEvent;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

import java.math.BigInteger;
import java.util.Optional;
import java.util.UUID;

@Repository
public interface ConnectNotificationEventRepository extends JpaRepository<ConnectNotificationEvent, Long> {

    Optional<ConnectNotificationEvent> findByEventId(UUID eventId);

}

package com.scb.scroeconnect.emailworker.repository;

import com.scb.scroeconnect.emailworker.entity.ConnectNotificationRecipient;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

@Repository
public interface ConnectNotificationRecipientRepository extends JpaRepository<ConnectNotificationRecipient, Long> {
}

package com.scb.scroeconnect.emailworker.repository;

import com.scb.scroeconnect.emailworker.entity.ConnectNotificationTemplate;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

import java.math.BigInteger;

@Repository
public interface ConnectNotificationTemplateRepository extends JpaRepository<ConnectNotificationTemplate, Long> {

}

package com.scb.scroeconnect.emailworker.service.asyncservice;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.scb.scroeconnect.emailworker.entity.ConnectNotificationDelivery;
import com.scb.scroeconnect.emailworker.entity.ConnectNotificationEmailInfo;
import com.scb.scroeconnect.emailworker.entity.ConnectNotificationEvent;
import com.scb.scroeconnect.emailworker.enums.DeliveryStatus;
import com.scb.scroeconnect.emailworker.repository.*;
import com.scb.scroeconnect.emailworker.service.EmailWorkerService;
import com.scb.scroeconnect.emailworker.util.SaveFinalPayloadUtil;
import lombok.RequiredArgsConstructor;
import lombok.extern.log4j.Log4j2;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.scheduling.annotation.Async;
import org.springframework.stereotype.Service;
import com.scb.scroeconnect.emailworker.util.RetryHandler;

import java.util.Date;

@Log4j2
@RequiredArgsConstructor
@Service
public class EmailAsyncProcessorService {

    private static final Logger logger = LogManager.getLogger(EmailAsyncProcessorService.class);

    @Autowired
    private final ConnectNotificationEventRepository connectNotificationEventRepository;
    @Autowired
    private final ConnectNotificationTemplateRepository connectNotificationTemplateRepository;
    @Autowired
    private final ConnectEventEmailConfigRepository connectEventEmailConfigRepository;

    @Autowired
    private final ConnectEmailInfoRepository connectEmailInfoRepository;

    @Autowired
    private final RetryHandler retryHandler;

    @Autowired
    private final SaveFinalPayloadUtil saveFinalPayloadUtil;

    private final EmailWorkerService emailWorkerService;

    private final ConnectNotificationDeliveryRepository connectNotificationDeliveryRepository;

    @Async("emailWorkerExecutor")
    public void processAsyncEmail(ConnectNotificationDelivery delivery) {
        try {
            logger.info("Sending Email Notification {}", delivery);
            emailWorkerService.sendEmailNotification(delivery);
            logger.info("Update Notification Status {}", delivery);
            // Retrieve the ConnectNotificationEvent entity

        } catch (Exception ex) {
            logger.error("Error while sending email:", ex);
            retryHandler.handleFailure(delivery);
        }
    }



}

package com.scb.scroeconnect.emailworker.service;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.node.ObjectNode;
import com.scb.scroeconnect.emailworker.config.EmailWorkerConfig;
import com.scb.scroeconnect.emailworker.config.RetryableRestTemplate;
import com.scb.scroeconnect.emailworker.dto.ContentBodyDTO;
import com.scb.scroeconnect.emailworker.dto.EmailRequestDTO;
import com.scb.scroeconnect.emailworker.dto.TransformedPayloadDTO;
import com.scb.scroeconnect.emailworker.entity.ConnectEventEmailConfig;
import com.scb.scroeconnect.emailworker.entity.ConnectNotificationDelivery;
import com.scb.scroeconnect.emailworker.enums.DeliveryStatus;
import com.scb.scroeconnect.emailworker.repository.ConnectEventEmailConfigRepository;
import com.scb.scroeconnect.emailworker.repository.ConnectNotificationDeliveryRepository;
//import com.scb.scroeconnect.emailworker.service.asyncservice.EmailAsyncProcessorService;
import com.scb.scroeconnect.emailworker.util.RetryHandler;
import com.scb.scroeconnect.emailworker.util.SaveFinalPayloadUtil;
import jakarta.transaction.Transactional;
import lombok.extern.log4j.Log4j2;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.*;
import org.springframework.stereotype.Service;

import java.nio.charset.StandardCharsets;
import java.util.Base64;
import java.util.Optional;

@Log4j2
@Service
public class EmailWorkerService {
    private static final ObjectMapper OBJECT_MAPPER = new ObjectMapper();
    private static final Logger logger = LogManager.getLogger(EmailWorkerService.class);

    private final ConnectNotificationDeliveryRepository connectNotificationDeliveryRepository;
    private final ConnectEventEmailConfigRepository connectEventEmailConfigRepository;
    private final RetryableRestTemplate restTemplate;
    private final EmailWorkerConfig emailWorkerConfig;

    @Autowired
    private final RetryHandler retryHandler;

    private final SaveFinalPayloadUtil saveFinalPayloadUtil;

   // private final EmailAsyncProcessorService emailAsyncProcessorService;

    public EmailWorkerService(ConnectEventEmailConfigRepository connectEventEmailConfigRepository, RetryableRestTemplate restTemplate, EmailWorkerConfig emailWorkerConfig, ConnectNotificationDeliveryRepository connectNotificationDeliveryRepository,RetryHandler retryHandler, SaveFinalPayloadUtil saveFinalPayloadUtil) {
        this.connectEventEmailConfigRepository = connectEventEmailConfigRepository;
        this.restTemplate = restTemplate;
        this.emailWorkerConfig = emailWorkerConfig;
        this.connectNotificationDeliveryRepository = connectNotificationDeliveryRepository;
        //this.emailAsyncProcessorService = emailAsyncProcessorService;
        this.retryHandler=retryHandler;
        this.saveFinalPayloadUtil=saveFinalPayloadUtil;

    }

    @Transactional
    public void sendEmailNotification(ConnectNotificationDelivery connectNotificationDelivery) throws JsonProcessingException {
        logger.info("Processing email notification for delivery ID: {}", connectNotificationDelivery.getId());

        // Get the final payload
        EmailRequestDTO finalPayload = getFinalPayload(connectNotificationDelivery);

        // Send the email
        boolean emailSent = sendEmail(finalPayload);
        if (emailSent) {
            logger.info("Email sent successfully for delivery ID: {}", connectNotificationDelivery.getId());
            connectNotificationDeliveryRepository.updateStatusById(connectNotificationDelivery.getId(), DeliveryStatus.SENT.toString());
            saveFinalPayloadUtil.saveFinalPayload(connectNotificationDelivery,finalPayload);
        } else {
            logger.warn("Failed to send email for delivery ID: {}", connectNotificationDelivery.getId());
            retryHandler.handleFailure(connectNotificationDelivery);

        }
    }

    public EmailRequestDTO getFinalPayload(ConnectNotificationDelivery delivery) throws JsonProcessingException {
        logger.info("Generating final payload for delivery ID: {}", delivery.getId());

        // Deserialize transformedPayload into TransformedPayloadDTO
        String transformedPayload = delivery.getTransformedPayload();
        if (transformedPayload == null) {
            throw new IllegalStateException("Transformed payload is null");
        }
        TransformedPayloadDTO payload = OBJECT_MAPPER.readValue(transformedPayload, TransformedPayloadDTO.class);

        // Retrieve email configuration
        Optional<ConnectEventEmailConfig> connectEventEmailConfigOptional = connectEventEmailConfigRepository.findByRecipientId(delivery.getRecipient().getId());
        if (connectEventEmailConfigOptional.isEmpty()) {
            throw new IllegalStateException("No email configuration found for recipient ID: " + delivery.getRecipient().getId());
        }
        ConnectEventEmailConfig connectEventEmailConfig = connectEventEmailConfigOptional.get();

        // Extract contentBody from TransformedPayloadDTO and encode as Base64
        ContentBodyDTO contentBodyDTO = payload.getContentBody();
        String json = OBJECT_MAPPER.writeValueAsString(contentBodyDTO);
        String contentBody = Base64.getEncoder().encodeToString(json.getBytes(StandardCharsets.UTF_8));

        // Construct EmailRequestDTO
        EmailRequestDTO finalPayload = new EmailRequestDTO();
        finalPayload.set_id("2001");
        finalPayload.setCountry(payload.getCountry());
        finalPayload.setRecipients(connectEventEmailConfig.getRecipients());
        finalPayload.setCc(connectEventEmailConfig.getCc());
        finalPayload.setBcc(connectEventEmailConfig.getBcc());
        finalPayload.setReplyTo(connectEventEmailConfig.getReplyTo());
        finalPayload.setNotificationType(payload.getNotificationType());
        finalPayload.setSubject(payload.getSubject());
        finalPayload.setContentType(payload.getContentType());
        finalPayload.setContentBody(contentBody);
        finalPayload.setEncoding("Base64");
        finalPayload.setPriority(payload.getPriority());
        finalPayload.setAttachments(null); // For now

        // Remove null fields
        removeNullFields(finalPayload);

        logger.info("Generated final payload: {}", finalPayload);
        return finalPayload;
    }

    private boolean sendEmail(EmailRequestDTO finalPayload) {
        HttpHeaders headers = new HttpHeaders();
        headers.setContentType(MediaType.APPLICATION_JSON);

        HttpEntity<EmailRequestDTO> requestEntity = new HttpEntity<>(finalPayload, headers);
        ResponseEntity<String> response = restTemplate.exchange(
                    emailWorkerConfig.getSendEmailApi(),
                    HttpMethod.POST,
                    requestEntity);
        System.out.println(finalPayload.toString());
        if (!response.getStatusCode().is2xxSuccessful()) {
            log.error("Failed to send email. Response: {}", response.getBody());
            //throw new RuntimeException("Failed to send email");
            return false;
        }
        return true;

    }

    private void removeNullFields(EmailRequestDTO finalPayload) {
        try {
            ObjectNode objectNode = OBJECT_MAPPER.valueToTree(finalPayload);

            // Remove all fields with null values
            objectNode.fields().forEachRemaining(entry -> {
                if (entry.getValue().isNull()) {
                    objectNode.remove(entry.getKey());
                }
            });

            // Update the finalPayload object with the modified ObjectNode
            OBJECT_MAPPER.readerForUpdating(finalPayload).readValue(objectNode);
        } catch (Exception e) {
            throw new RuntimeException("Failed to remove null fields", e);
        }
    }
}

package com.scb.scroeconnect.emailworker.util;

import com.scb.scroeconnect.emailworker.entity.ConnectNotificationDelivery;
import com.scb.scroeconnect.emailworker.enums.DeliveryStatus;
import com.scb.scroeconnect.emailworker.repository.ConnectNotificationDeliveryRepository;
import com.scb.scroeconnect.emailworker.service.asyncservice.EmailAsyncProcessorService;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Component;

import java.util.Date;


@Component
public class RetryHandler {

    @Autowired
    ConnectNotificationDeliveryRepository connectNotificationDeliveryRepository;

    @Value("${app.worker.max-retries}")
    private int maxRetries;
    private static final Logger logger = LogManager.getLogger(EmailAsyncProcessorService.class);

    public void handleFailure(ConnectNotificationDelivery delivery) {
        int nextRetry = delivery.getRetryCount() + 1;
        if (nextRetry > maxRetries) {
            logger.error("Max retry limit reached for delivery ID: {}", delivery.getId());
            connectNotificationDeliveryRepository.updateStatusById(delivery.getId(), DeliveryStatus.FAILED.name());
            return;
        }
        Date nextRetryTime = calculateBackoff(nextRetry);
        connectNotificationDeliveryRepository.updateStatusAndRetryById(delivery.getId(), DeliveryStatus.RETRY.name(), nextRetryTime);
    }
    public Date calculateBackoff(int retryCount) {
        long delaySeconds = (long) Math.pow(2, retryCount) * 60;
        return new Date(System.currentTimeMillis() + delaySeconds * 1000);
    }
}

package com.scb.scroeconnect.emailworker.util;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.scb.scroeconnect.emailworker.dto.EmailRequestDTO;
import com.scb.scroeconnect.emailworker.entity.ConnectNotificationDelivery;
import com.scb.scroeconnect.emailworker.entity.ConnectNotificationEmailInfo;
import com.scb.scroeconnect.emailworker.entity.ConnectNotificationEvent;
import com.scb.scroeconnect.emailworker.repository.ConnectEmailInfoRepository;
import com.scb.scroeconnect.emailworker.repository.ConnectNotificationEventRepository;
import com.scb.scroeconnect.emailworker.service.EmailWorkerService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Component;

@Component
public class SaveFinalPayloadUtil
{
        @Autowired
        private ConnectNotificationEventRepository connectNotificationEventRepository;

        @Autowired
        private ConnectEmailInfoRepository connectEmailInfoRepository;

    public void saveFinalPayload(ConnectNotificationDelivery delivery, EmailRequestDTO finalPayload) throws JsonProcessingException {
        ConnectNotificationEvent notificationEvent = connectNotificationEventRepository
                .findByEventId(delivery.getNotificationEvent().getEventId())
                .orElseThrow(() -> new RuntimeException("Event not found for ID: " + delivery.getNotificationEvent().getEventId()));

        // Create and populate the ConnectNotificationEmailInfo entity
        ConnectNotificationEmailInfo connectNotificationEmailInfo = new ConnectNotificationEmailInfo();
        connectNotificationEmailInfo.setNotificationEvent(notificationEvent);
        connectNotificationEmailInfo.setEmailPayload(finalPayload);
        connectNotificationEmailInfo.setNotificationDelivery(delivery);

        // Save the entity
        connectEmailInfoRepository.save(connectNotificationEmailInfo);
    }
}

Write testcases for all the classes no matter the result it should have 100% line code coverage
package com.scb.scroeconnect.solaceworker.config;

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.scheduling.annotation.EnableAsync;
import org.springframework.scheduling.annotation.EnableScheduling;
import org.springframework.scheduling.concurrent.ThreadPoolTaskExecutor;

import java.util.concurrent.Executor;

@Configuration
@EnableAsync
@EnableScheduling
public class AsyncSolaceConfig {
    @Bean("solaceWorkerExecutor")
    public Executor emailWorkerExecutor() {
        ThreadPoolTaskExecutor executor = new ThreadPoolTaskExecutor();
        executor.setCorePoolSize(10);
        executor.setMaxPoolSize(20);
        executor.setQueueCapacity(200);
        executor.setThreadNamePrefix("solace-worker-async");
        executor.initialize();
        return executor;
    }
}

package com.scb.scroeconnect.solaceworker.config;

import com.scb.scroeconnect.solaceworker.entity.ConnectSolaceConfig;
import com.scb.scroeconnect.solaceworker.repository.ConnectSolaceConfigRepository;
import com.scb.scroeconnect.solaceworker.repository.ConnectSolaceWorkerRepository;
import com.solacesystems.jcsmp.*;
import com.solacesystems.jms.SolConnectionFactory;
import com.solacesystems.jms.SolJmsUtility;
import com.solacesystems.jms.message.SolMessage;
import lombok.extern.log4j.Log4j2;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Qualifier;
import org.springframework.context.ApplicationListener;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Lazy;
import org.springframework.context.event.ContextClosedEvent;
import org.springframework.stereotype.Component;

import javax.jms.Connection;
import javax.jms.Destination;
import javax.jms.JMSException;
import javax.jms.MessageProducer;
import javax.jms.Session;
import java.util.Map;

@Log4j2
@Component
public class SolaceConnectionConfig implements ApplicationListener<ContextClosedEvent> {

    private final ConnectSolaceConfigRepository connectSolaceConfigRepository;

    private final SolacePropertiesConstant solacePropertiesConstant;

    @Lazy
    @Autowired
    @Qualifier("rcmsSession")
    private Session session;

    @Lazy
    @Autowired
    @Qualifier("rcmsConnection")
    private Connection connection;

    public SolaceConnectionConfig(ConnectSolaceConfigRepository connectSolaceConfigRepository, SolacePropertiesConstant solacePropertiesConstant) {
        this.connectSolaceConfigRepository = connectSolaceConfigRepository;
        this.solacePropertiesConstant = solacePropertiesConstant;
    }

    @Bean("rcmsSolConnectionFactory")
    public SolConnectionFactory createSolConnectionFactory() throws Exception {
        ConnectSolaceConfig connectSolaceConfig = connectSolaceConfigRepository.findFirstByActive("Y").orElseThrow(() -> new RuntimeException("No active Solace configuration found"));
        Map<String, String> queue = solacePropertiesConstant.getQueue();
        Map<String, String> ssl = solacePropertiesConstant.getSsl();

        SolConnectionFactory cf = SolJmsUtility.createConnectionFactory();
        cf.setVPN(connectSolaceConfig.getVpn());
        cf.setHost(connectSolaceConfig.getHostname());
        cf.setUsername(connectSolaceConfig.getUsername());
        cf.setPassword(connectSolaceConfig.getPassword());
        cf.setConnectRetries(solacePropertiesConstant.getConnectRetries());
        cf.setConnectRetriesPerHost(solacePropertiesConstant.getConnectRetriesPerHost());
        cf.setConnectTimeoutInMillis(solacePropertiesConstant.getConnectTimeoutInMillis());
        cf.setClientID(connectSolaceConfig.getClientId());

        cf.setSSLTrustStore(ssl.get("truststorePath"));
        cf.setSSLTrustStorePassword(ssl.get("truststorePassword"));
        cf.setSSLTrustStoreFormat(ssl.get("truststoreType"));
        cf.setSSLKeyStore(ssl.get("keystorePath"));
        cf.setSSLKeyStorePassword(ssl.get("keystorePassword"));
        cf.setSSLKeyStoreFormat(ssl.get("keystoreType"));
        cf.setAuthenticationScheme("AUTHENTICATION_SCHEME_CLIENT_CERTIFICATE");
        return cf;
    }

    @Bean("rcmsConnection")
    public Connection createConnection(@Qualifier("rcmsSolConnectionFactory") SolConnectionFactory cf) throws Exception {
        return cf.createConnection();
    }

    @Bean("rcmsSession")
    public javax.jms.Session createSession(@Qualifier("rcmsConnection") Connection connection) throws Exception {
        return connection.createSession(false, javax.jms.Session.CLIENT_ACKNOWLEDGE);
    }

    @Override
    public void onApplicationEvent(ContextClosedEvent event) {
        if (session != null)
            try {
                session.close();
            } catch (JMSException e) {
                log.error("Error while closing session", e);
            }
        if (connection != null)
            try {
                connection.close();
            } catch (JMSException e) {
                log.error("Error while closing connection", e);
            }
    }

    public void sendMessage(String topicName, String message, String caseRef) throws JMSException {
        Destination destination = session.createTopic(topicName);
        MessageProducer producer = session.createProducer(destination);
        SolMessage textMessage = (SolMessage) session.createTextMessage((String) message);
        textMessage.setJMSTimestamp(System.currentTimeMillis());
        textMessage.setJMSCorrelationID(caseRef);
        producer.send(textMessage);
        log.info(textMessage.getJMSMessageID());
        if (producer != null) producer.close();
    }
}

package com.scb.scroeconnect.solaceworker.config;

import lombok.Getter;
import lombok.Setter;
import org.springframework.boot.context.properties.ConfigurationProperties;
import org.springframework.context.annotation.Configuration;

import java.util.Map;

@Getter
@Setter
@Configuration
@ConfigurationProperties(prefix = "solace.rcms")
public class SolacePropertiesConstant {
    private Map<String, String> queue;
    private Map<String, String> ssl;
    private int connectTimeoutInMillis;
    private int connectRetries;
    private int connectRetriesPerHost;
}

package com.scb.scroeconnect.solaceworker.config;

import org.springframework.beans.factory.annotation.Value;
import org.springframework.context.annotation.Configuration;

@Configuration
public class SolaceWorkerConfig {

    @Value("$solace.notification.topic")
    private String solaceNotificationTopic;

    public SolaceWorkerConfig() {
    }

    public String getSolaceNotificationTopic() {
        return solaceNotificationTopic;
    }

    public void setSolaceNotificationTopic(String solaceNotificationTopic) {
        this.solaceNotificationTopic = solaceNotificationTopic;
    }
}

package com.scb.scroeconnect.solaceworker.dto.FinalPayloadDto;

import lombok.Data;

import java.math.BigDecimal;
import java.time.LocalDateTime;

@Data
public class FinalPayloadBodyDto {
    private String physicalAccountNbr;
    private String iban;
    private String accountCurrency;
    private String accountCountry;
    private String vaNumber;
    private String vaultNbr;
    private BigDecimal amount;
    private String crDrIndicator;
    private LocalDateTime txnDate;

    private LocalDateTime cbValueDate;
    private String sourceChannelId;
    private String txnReferenceNo;

    private String relatedReferenceNo;
    private String rtatransID;
    private String appSeqNo;

    private String narration1;
    private String narration2;
    private String narration3;
    private String narration4;
    private String narration5;
    private String narration6;
}

package com.scb.scroeconnect.solaceworker.dto.FinalPayloadDto;

import lombok.Data;
import com.scb.scroeconnect.solaceworker.dto.TrailerDto;

import java.util.List;

@Data
public class FinalPayloadDto {

    private FinalPayloadHeaderDto header;
    private List<FinalPayloadBodyDto> body;
    private TrailerDto trailer;
}

package com.scb.scroeconnect.solaceworker.dto.FinalPayloadDto;

import lombok.Data;

import java.time.LocalDateTime;

@Data
public class FinalPayloadHeaderDto {
    private String notificationType;
    private String messageId;
    private LocalDateTime initiatedTimeStamp;
}

package com.scb.scroeconnect.solaceworker.dto.TransformedPayloadDto;

import lombok.Data;

@Data
public class TransformedBodyDto {
    private String clientId;
    private String physicalAccountNbr;
    private String iban;
    private String accountCurrency;
    private String accountCountry;
    private String vaNumber;
    private String vaultNbr;
    private String amount;
    private String crDrIndicator;
    private String txnDate;

    private String cbValueDate;
    private String sourceChannelId;
    private String txnReferenceNo;

    private String relatedReferenceNo;
    private String rtatransID;
    private String appSeqNo;

    private String narration1;
    private String narration2;
    private String narration3;
    private String narration4;
    private String narration5;
    private String narration6;

}

package com.scb.scroeconnect.solaceworker.dto.TransformedPayloadDto;

import lombok.Getter;
import lombok.Setter;

@Getter
@Setter
public class TransformedHeaderDto {
    private String notificationType;
}

package com.scb.scroeconnect.solaceworker.dto.TransformedPayloadDto;

import lombok.Data;
import com.scb.scroeconnect.solaceworker.dto.TrailerDto;

import java.util.List;

@Data
public class TransformedPayloadDto {

    private TransformedHeaderDto header;
    private List<TransformedBodyDto> body;
    private TrailerDto trailer;
}

package com.scb.scroeconnect.solaceworker.dto;

import lombok.Data;

@Data
public class TrailerDto {
    private String recordCount;
}

package com.scb.scroeconnect.solaceworker.entity;

import jakarta.persistence.Column;
import jakarta.persistence.MappedSuperclass;
import lombok.Getter;
import lombok.Setter;
import org.hibernate.annotations.CreationTimestamp;
import org.hibernate.annotations.UpdateTimestamp;

import java.sql.Timestamp;

@Getter
@Setter
@MappedSuperclass
public abstract class BaseEntity {

    @Column(name = "created_at", nullable = false, updatable = false)
    @CreationTimestamp
    private Timestamp createdAt;

    @Column(name = "updated_at", nullable = false)
    @UpdateTimestamp
    private Timestamp updatedAt;
}

package com.scb.scroeconnect.solaceworker.entity;


import jakarta.persistence.*;
import lombok.Getter;
import lombok.Setter;

import java.sql.Timestamp;

@Entity
@Getter
@Setter
@Table(name = "connect_notification_delivery")
public class ConnectNotificationDelivery extends BaseEntity {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "event_id",referencedColumnName = "event_id",nullable = false)
    private NotificationEvent notificationEvent;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "recipient_id", nullable = false)
    private Recipient recipient;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "template_id", nullable = false)
    private NotificationTemplate notificationTemplate;

    @Column(name = "delivery_mode", nullable = false)
    private String deliveryMode;

    @Column(name = "transformed_payload", columnDefinition = "TEXT")
    private String transformedPayload;

    @Column(nullable = false)
    private String status;

    @Column(name = "retry_count", nullable = false)
    private int retryCount;

    @Column(name = "available_at", nullable = false)
    private Timestamp availableAt;

}

package com.scb.scroeconnect.solaceworker.entity;

import jakarta.persistence.*;
import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;

@Entity
@Table(name = "connect_solace_config")
@Getter
@Setter
@AllArgsConstructor
@NoArgsConstructor
public class ConnectSolaceConfig extends BaseEntity {
    @Id
    @Column(name = "solace_config_id", nullable = false)
    private Long solaceConfigId;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "recipient_id",referencedColumnName = "id", nullable = false)
    private Recipient recipient;

    @Column(name = "host", nullable = false)
    private String hostname;

    @Column(name = "topic", nullable = false)
    private String topic;

    @Column(name = "clientId", nullable = false)
    private String clientId;

    @Column(name = "vpn", nullable = false)
    private String vpn;

    @Column(name = "username", nullable = false)
    private String username;

    @Column(name = "password", nullable = false)
    private String password;

    @Column(name = "active", nullable = false)
    private String active;
}

package com.scb.scroeconnect.solaceworker.entity;

import jakarta.persistence.*;
import lombok.Getter;
import lombok.Setter;

import java.time.LocalDateTime;

@Entity
@Table(name = "connect_solace_worker")
@Getter
@Setter
public class ConnectSolaceWorker {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    @Column(name = "id", nullable = false)
    private Long id;

    @OneToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "notification_delivery_id", referencedColumnName = "id", nullable = false)
    private ConnectNotificationDelivery notificationDelivery;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "event_id",referencedColumnName = "event_id",nullable = false)
    private NotificationEvent notificationEvent;

    @Column(name = "final_payload", columnDefinition = "TEXT")
    private String finalPayload;

    @Column(name = "send_at")
    private LocalDateTime sendAt;
}

package com.scb.scroeconnect.solaceworker.entity;

import jakarta.persistence.*;
import lombok.Data;

import java.sql.Timestamp;
import java.util.UUID;

@Data
@Entity
@Table(name = "connect_notification_event")
public class NotificationEvent extends BaseEntity {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(nullable = false, unique = true ,name = "event_id")
    private UUID eventId;

    @Column(nullable = false,name = "client_id")
    private String clientId;

    @Column(nullable = false,name = "event_type")
    private String eventType;

    @Column(columnDefinition = "TEXT")
    private String payload;

    @Column(nullable = false)
    private String status;

    @Column(nullable = false, name = "available_at")
    private Timestamp availableAt;

    @Column(nullable = false,name = "retry_count")
    private Integer retryCount;

    @PrePersist
    protected void onCreate() {
        // this.createdAt = LocalDateTime.now();
        // this.updatedAt = LocalDateTime.now();
        this.availableAt = new Timestamp(System.currentTimeMillis());
    }

}

package com.scb.scroeconnect.solaceworker.entity;

import jakarta.persistence.Entity;
import jakarta.persistence.*;
import lombok.Data;
import org.antlr.v4.runtime.misc.NotNull;

@Data
@Entity
@Table(name = "connect_notification_template")
public class NotificationTemplate extends BaseEntity{

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(nullable = false)
    @NotNull
    private String name;

    @Column(name = "template_type", nullable = false)
    @NotNull
    private String templateType;

    @Column(columnDefinition = "TEXT", nullable = false)
    @NotNull
    private String template;

    @Column(name = "delete_flag", nullable = false)
    private boolean deleteFlag;
}

package com.scb.scroeconnect.solaceworker.entity;

import jakarta.persistence.*;
import lombok.Data;
import org.antlr.v4.runtime.misc.NotNull;

@Data
@Entity
@Table(name = "connect_notification_recipient")
public class Recipient {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(name = "recipient_ref", nullable = false)
    @NotNull
    private String recipientRef;

    @Column(nullable = false)
    @NotNull
    private boolean active;

    @Column(name = "recipient_type", nullable = false)
    @NotNull
    private String recipientType;
}

package com.scb.scroeconnect.solaceworker.enums;

public enum DeliveryStatus {
    PENDING,
    SENT,
    RETRY,
}

package com.scb.scroeconnect.solaceworker.poller;

import static com.scb.scroeconnect.solaceworker.util.Constants.BATCH_SIZE;

import com.scb.scroeconnect.solaceworker.service.asyncservice.SolaceAsyncProcessorService;
import lombok.RequiredArgsConstructor;
import lombok.extern.log4j.Log4j2;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;
import com.scb.scroeconnect.solaceworker.entity.ConnectNotificationDelivery;
import org.springframework.scheduling.annotation.Scheduled;
import com.scb.scroeconnect.solaceworker.repository.ConnectNotificationDeliveryRepository;
import org.springframework.stereotype.Component;

import java.util.List;


@Log4j2
@Component
@RequiredArgsConstructor
public class SolacePoller {
    private static final Logger logger = LogManager.getLogger(SolacePoller.class);

    private final ConnectNotificationDeliveryRepository connectNotificationDeliveryRepository;
    private final SolaceAsyncProcessorService solaceAsyncProcessorService;

    @Scheduled(fixedDelay = 10000) // Poll every 10 seconds
    public void pollSolace() {

        logger.info("Polling Solace looking  for new messages...");
        // Fetch messages from Solace (this is a placeholder, implement actual fetching logic)
        try{
            logger.info("Fetching Pending Solace Deliveries");
            List<ConnectNotificationDelivery> batch = connectNotificationDeliveryRepository.findPendingSolaceDeliveries(BATCH_SIZE);
            if(batch.isEmpty()){
                logger.info("No pending Solace deliveries found.");
                return;
            }
            // processing each message
            for (ConnectNotificationDelivery delivery : batch) {
                solaceAsyncProcessorService.processAsyncSolace(delivery);
            }

        }catch (Exception e){
            logger.error("Error while polling Solace: ", e);
            throw new RuntimeException("Error while fetching Pending Solace Deliveries:", e);
        }
    }
}

package com.scb.scroeconnect.solaceworker.repository;

import com.scb.scroeconnect.solaceworker.entity.ConnectNotificationDelivery;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Modifying;
import org.springframework.data.jpa.repository.Query;
import org.springframework.data.repository.query.Param;
import org.springframework.transaction.annotation.Transactional;

import java.math.BigInteger;
import java.util.List;
import java.util.Date;

public interface ConnectNotificationDeliveryRepository extends JpaRepository<ConnectNotificationDelivery, Long> {

    @Transactional
    @Query( value = """
           WITH cte AS (
                SELECT id
                FROM connect_notification_delivery
                WHERE status IN ('PENDING', 'RETRY')
                  AND delivery_mode = 'Solace'
                  AND (available_at IS NULL OR available_at <= NOW())
                ORDER BY id
                FOR UPDATE SKIP LOCKED
                LIMIT :batchSize
           )
           UPDATE connect_notification_delivery
           SET status = 'PROCESSING',
               updated_at = NOW()
           WHERE id IN (SELECT id FROM cte)
           RETURNING *
            """,nativeQuery = true)
    List<ConnectNotificationDelivery> findPendingSolaceDeliveries(@Param("batchSize") int batchSize);

    @Modifying
    @Transactional
    @Query(value = "UPDATE connect_notification_delivery SET status = :status, " +
            "retry_count = retry_count + 1, available_at = :availableAt, updated_at = NOW() WHERE id = :id", nativeQuery = true)
    void updateStatusAndRetryById(Long id, String status, Date availableAt);

    @Modifying
    @Transactional
    @Query(value = "UPDATE connect_notification_delivery SET status = :status, " +
            "updated_at = NOW() WHERE id = :id", nativeQuery = true)
    void updateStatusById(Long id, String status);

    @Modifying
    @Transactional
    @Query(value = "UPDATE connect_notification_delivery SET status = 'SENT', " +
            "updated_at = NOW() WHERE id = :id", nativeQuery = true)
    void markSent(@Param("id") Long id);

    @Modifying
    @Transactional
    @Query(value = "UPDATE connect_notification_delivery SET status = 'FAILED', " +
            "updated_at = NOW() WHERE id = :id", nativeQuery = true)
    void updateStatusFailedById(Long id);
}

package com.scb.scroeconnect.solaceworker.repository;

import com.scb.scroeconnect.solaceworker.entity.NotificationEvent;
import org.aspectj.weaver.ast.Not;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

import java.util.Optional;
import java.util.UUID;

@Repository
public interface ConnectNotificationEventRepository extends JpaRepository<NotificationEvent, Long> {

    Optional<NotificationEvent> findByEventId(UUID eventId);

}

package com.scb.scroeconnect.solaceworker.repository;

import com.scb.scroeconnect.solaceworker.entity.ConnectSolaceConfig;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Query;

import java.util.Optional;

public interface ConnectSolaceConfigRepository extends JpaRepository<ConnectSolaceConfig, Long> {
    @Query(value = "SELECT * FROM connect_solace_config WHERE recipient_id = :recipientId AND active = 'Y'", nativeQuery = true)
    Optional<ConnectSolaceConfig> findByRecipientIdAndActive(Long recipientId);

    Optional<ConnectSolaceConfig> findFirstByActive(String active);
}

package com.scb.scroeconnect.solaceworker.repository;

import com.scb.scroeconnect.solaceworker.entity.ConnectSolaceWorker;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Modifying;
import org.springframework.data.jpa.repository.Query;
import org.springframework.data.repository.query.Param;
import org.springframework.transaction.annotation.Transactional;

import java.time.LocalDateTime;

public interface ConnectSolaceWorkerRepository extends JpaRepository<ConnectSolaceWorker, Long> {

    @Modifying
    @Transactional
    @Query(value = """
        INSERT INTO connect_solace_worker (notification_delivery_id, event_id, final_payload, send_at)
        VALUES (:notificationDeliveryId, :eventId, :finalPayload, :sendAt)
        """, nativeQuery = true)
    void insertIntoConnectSolaceWorker(@Param("notificationDeliveryId") Long notificationDeliveryId,
                                       @Param("eventId") Long eventId,
                                       @Param("finalPayload") String finalPayload,
                                       @Param("sendAt") LocalDateTime sendAt);
}

package com.scb.scroeconnect.solaceworker.service.asyncservice;

import com.scb.scroeconnect.solaceworker.util.RetryHandler;
import lombok.RequiredArgsConstructor;
import lombok.extern.log4j.Log4j2;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;
import com.scb.scroeconnect.solaceworker.entity.ConnectNotificationDelivery;
import com.scb.scroeconnect.solaceworker.service.SolaceWorkerService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.scheduling.annotation.Async;
import org.springframework.stereotype.Service;

@Log4j2
@RequiredArgsConstructor
@Service
public class SolaceAsyncProcessorService {
    private static final Logger logger = LogManager.getLogger(SolaceAsyncProcessorService.class);
    @Autowired
    private final SolaceWorkerService solaceWorkerService;
    @Autowired
    private final RetryHandler retryHandler;

    @Async("solaceWorkerExecutor")
    public void processAsyncSolace(ConnectNotificationDelivery delivery) {
        try {
            logger.info("Sending Solace Notification {}", delivery);

            solaceWorkerService.sendSolaceNotification(delivery);

            logger.info("Update Notification Status {}", delivery);
        } catch (Exception ex) {
            logger.error("Error while sending email:", ex);
            retryHandler.handleFailure(delivery);
        }
    }
}

package com.scb.scroeconnect.solaceworker.service;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectWriter;
import com.scb.scroeconnect.solaceworker.config.SolaceConnectionConfig;
import com.scb.scroeconnect.solaceworker.enums.DeliveryStatus;
import com.scb.scroeconnect.solaceworker.util.RetryHandler;
import com.scb.scroeconnect.solaceworker.util.SaveFinalPayloadUtil;
import lombok.extern.log4j.Log4j2;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.scb.scroeconnect.solaceworker.dto.FinalPayloadDto.FinalPayloadBodyDto;
import com.scb.scroeconnect.solaceworker.dto.FinalPayloadDto.FinalPayloadDto;
import com.scb.scroeconnect.solaceworker.dto.FinalPayloadDto.FinalPayloadHeaderDto;
import com.scb.scroeconnect.solaceworker.dto.TransformedPayloadDto.TransformedBodyDto;
import com.scb.scroeconnect.solaceworker.dto.TransformedPayloadDto.TransformedPayloadDto;
import com.scb.scroeconnect.solaceworker.entity.ConnectNotificationDelivery;
import com.scb.scroeconnect.solaceworker.entity.ConnectSolaceConfig;
import com.scb.scroeconnect.solaceworker.repository.ConnectNotificationDeliveryRepository;
import com.scb.scroeconnect.solaceworker.repository.ConnectSolaceConfigRepository;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.math.BigDecimal;
import java.time.LocalDateTime;
import java.util.List;
import java.util.Optional;
import java.util.UUID;

@Log4j2
@Service
public class SolaceWorkerService {

    private static final Logger logger = LogManager.getLogger(SolaceWorkerService.class);
    private final ConnectSolaceConfigRepository connectSolaceConfigRepository;
    private final ConnectNotificationDeliveryRepository connectNotificationDeliveryRepository;
    private final SolaceConnectionConfig solaceConnectionConfig;
    @Autowired
    private final RetryHandler retryHandler;

    private final SaveFinalPayloadUtil saveFinalPayloadUtil;

    public SolaceWorkerService(ConnectSolaceConfigRepository connectSolaceConfigRepository,
                               ConnectNotificationDeliveryRepository connectNotificationDeliveryRepository,
                               SolaceConnectionConfig solaceConnectionConfig, SaveFinalPayloadUtil saveFinalPayloadUtil,
                               RetryHandler retryHandler) {
        this.connectSolaceConfigRepository = connectSolaceConfigRepository;
        this.connectNotificationDeliveryRepository = connectNotificationDeliveryRepository;
        this.solaceConnectionConfig = solaceConnectionConfig;
        this.retryHandler = retryHandler;
        this.saveFinalPayloadUtil = saveFinalPayloadUtil;

    }

    @Transactional
    public void sendSolaceNotification(ConnectNotificationDelivery connectNotificationDelivery) {
        Optional<ConnectNotificationDelivery> delivery = connectNotificationDeliveryRepository.findById(connectNotificationDelivery.getId());
        if (delivery.isEmpty()) {
            logger.error("Delivery with ID {} not found", connectNotificationDelivery.getId());
            throw new IllegalStateException("Delivery not found");
        }

        String transformedPayload = connectNotificationDelivery.getTransformedPayload();
        TransformedPayloadDto payload;

        try {

            ObjectMapper objectMapper = new ObjectMapper();
            payload = objectMapper.readValue(transformedPayload, TransformedPayloadDto.class);

            logger.info(payload.getBody());
            logger.info(payload.getHeader());

        } catch (JsonProcessingException e) {
            logger.error("Error processing JSON: {}", e.getMessage(), e);
            throw new RuntimeException("Failed to parse transformed payload", e);
        }

        try {
            FinalPayloadDto finalPayload = new FinalPayloadDto();
            FinalPayloadHeaderDto headerDto = new FinalPayloadHeaderDto();
            FinalPayloadBodyDto bodyDto = new FinalPayloadBodyDto();

            headerDto.setNotificationType(payload.getHeader().getNotificationType());
            String messageId = UUID.randomUUID().toString();
            headerDto.setMessageId(messageId);
            headerDto.setInitiatedTimeStamp(LocalDateTime.now());
            finalPayload.setHeader(headerDto);

            TransformedBodyDto payloadBody = payload.getBody().get(0);

            bodyDto.setPhysicalAccountNbr(payloadBody.getPhysicalAccountNbr());
            bodyDto.setIban(payloadBody.getIban());
            bodyDto.setAccountCurrency(payloadBody.getAccountCurrency());
            bodyDto.setAccountCountry(payloadBody.getAccountCountry());
            bodyDto.setVaNumber(payloadBody.getVaNumber());
            bodyDto.setVaultNbr(payloadBody.getVaultNbr());
            bodyDto.setAmount(new BigDecimal(payloadBody.getAmount()));
            bodyDto.setCrDrIndicator(payloadBody.getCrDrIndicator());
            bodyDto.setTxnDate(LocalDateTime.parse(payloadBody.getTxnDate()));
            bodyDto.setCbValueDate(LocalDateTime.parse(payloadBody.getCbValueDate()));
            bodyDto.setSourceChannelId(payloadBody.getSourceChannelId());
            bodyDto.setTxnReferenceNo(payloadBody.getTxnReferenceNo());
            bodyDto.setRelatedReferenceNo(payloadBody.getRelatedReferenceNo());
            bodyDto.setRtatransID(payloadBody.getRtatransID());
            bodyDto.setAppSeqNo(payloadBody.getAppSeqNo());
            bodyDto.setNarration1(payloadBody.getNarration1());
            bodyDto.setNarration2(payloadBody.getNarration2());
            bodyDto.setNarration3(payloadBody.getNarration3());
            bodyDto.setNarration4(payloadBody.getNarration4());
            bodyDto.setNarration5(payloadBody.getNarration5());
            bodyDto.setNarration6(payloadBody.getNarration6());
            finalPayload.setBody(List.of(bodyDto));

            Long recipientId = connectNotificationDelivery.getRecipient().getId();
            boolean publish = publishToSolace(finalPayload, recipientId, connectNotificationDelivery.getNotificationEvent().getEventId());
            if (publish) {
                logger.info("Solace Notification sent successfully for delivery ID: {}", connectNotificationDelivery.getId());
                connectNotificationDeliveryRepository.updateStatusById(connectNotificationDelivery.getId(), DeliveryStatus.SENT.toString());
                saveFinalPayloadUtil.saveFinalPayload(connectNotificationDelivery, finalPayload);

            } else {
                logger.error("Failed to send Solace Notification delivery ID: {}", connectNotificationDelivery.getId());
                retryHandler.handleFailure(connectNotificationDelivery);
            }
        } catch (Exception e) {
            logger.error("Failed to send Solace Notification: {}", e.getMessage());
            throw new RuntimeException("Failed to send Solace Notification: ", e);
        }
    }

    public boolean publishToSolace(FinalPayloadDto finalPayload, Long recipientId, UUID eventId) {
        try {
            Optional<ConnectSolaceConfig> connectSolaceConfig = connectSolaceConfigRepository.findByRecipientIdAndActive(recipientId);
            if (connectSolaceConfig.isEmpty()) {
                logger.error("No active Solace configuration found for recipientId: {}", recipientId);
                throw new IllegalStateException("No active Solace configuration found for recipientId: " + recipientId);
            }
            ObjectWriter ow = new ObjectMapper().writer();
            String message = ow.writeValueAsString(finalPayload);
            log.info("Solace Final Payload Message : {}", message);
            solaceConnectionConfig.sendMessage(connectSolaceConfig.get().getTopic(), message, eventId.toString());
            return true;
        } catch (Exception e) {
            logger.error("Exception while sending Solace Notification: {} For Recipient Id: {}", e, recipientId);
            throw new RuntimeException("Exception while sending Solace Notification: " + e + "For Recipient Id: " + recipientId);
        }
    }

}

package com.scb.scroeconnect.solaceworker.util;

public class Constants {
    public static final int BATCH_SIZE = 10;
    public static final int MAX_RETRIES = 3;
}

package com.scb.scroeconnect.solaceworker.util;

import com.scb.scroeconnect.solaceworker.entity.ConnectNotificationDelivery;
import com.scb.scroeconnect.solaceworker.enums.DeliveryStatus;
import com.scb.scroeconnect.solaceworker.repository.ConnectNotificationDeliveryRepository;
import com.scb.scroeconnect.solaceworker.service.asyncservice.SolaceAsyncProcessorService;
import org.springframework.beans.factory.annotation.Autowired;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;
import org.springframework.stereotype.Component;

import java.util.Date;

@Component
public class RetryHandler {

    @Autowired
    ConnectNotificationDeliveryRepository connectNotificationDeliveryRepository;
    private static final Logger logger = LogManager.getLogger(SolaceAsyncProcessorService.class);

    public void handleFailure(ConnectNotificationDelivery delivery) {
        int nextRetry = delivery.getRetryCount() + 1;
        if (nextRetry > Constants.MAX_RETRIES) {
            logger.error("Max retry limit reached for delivery ID: {}", delivery.getId());
            connectNotificationDeliveryRepository.updateStatusFailedById(delivery.getId());
            return;
        }
        Date nextRetryTime = calculateBackoff(nextRetry);
        connectNotificationDeliveryRepository.updateStatusAndRetryById(delivery.getId(), DeliveryStatus.RETRY.name(), nextRetryTime);
    }
    public Date calculateBackoff(int retryCount) {
        long delaySeconds = (long) Math.pow(2, retryCount) * 60;
        return new Date(System.currentTimeMillis() + delaySeconds * 1000);
    }

}

package com.scb.scroeconnect.solaceworker.util;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.scb.scroeconnect.solaceworker.dto.FinalPayloadDto.FinalPayloadDto;
import com.scb.scroeconnect.solaceworker.entity.ConnectNotificationDelivery;
import com.scb.scroeconnect.solaceworker.entity.ConnectSolaceWorker;
import com.scb.scroeconnect.solaceworker.entity.NotificationEvent;
import com.scb.scroeconnect.solaceworker.repository.ConnectNotificationEventRepository;
import com.scb.scroeconnect.solaceworker.repository.ConnectSolaceWorkerRepository;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Component;

@Component
public class SaveFinalPayloadUtil
{
        @Autowired
        private ConnectNotificationEventRepository connectNotificationEventRepository;

        @Autowired
        private ConnectSolaceWorkerRepository connectSolaceWorkerRepository;

    public void saveFinalPayload(ConnectNotificationDelivery delivery, FinalPayloadDto finalPayload) throws JsonProcessingException {
        NotificationEvent notificationEvent = connectNotificationEventRepository
                .findByEventId(delivery.getNotificationEvent().getEventId())
                .orElseThrow(() -> new RuntimeException("Event not found for ID: " + delivery.getNotificationEvent().getEventId()));

        // Create and populate the ConnectNotificationEmailInfo entity
        ConnectSolaceWorker connectSolaceWorker = new ConnectSolaceWorker();
        connectSolaceWorker.setNotificationEvent(notificationEvent);
        connectSolaceWorker.setFinalPayload(String.valueOf(finalPayload));
        connectSolaceWorker.setNotificationDelivery(delivery);

        // Save the entity
        connectSolaceWorkerRepository.save(connectSolaceWorker);
    }
}
